/* client.c */
#include "function.h"

#define OURPORT 8088

gint sd; //套接字句柄
struct sockaddr_in s_in; //套接字数据结构
gchar username[64]; //用户名
gchar password[64]; //密码
gchar buf[MAX_LEN]; //写缓冲区
gchar get_buf[MAX_LEN]; //读缓冲区
gboolean isconnected = FALSE; //定义逻辑值表示是否连接

static GtkWidget *main_window;
static GtkWidget *text;
static GtkWidget *path_text;
static GtkTextBuffer *buffer; //显示对话内容的文本显示缓冲区
static GtkWidget *message_entry; //显示输入消息的单行录入控件
static GtkWidget *name_entry; //输入用户名的单行录入控件
static GtkWidget *password_entry; //输入用户名的单行录入控件
static GtkWidget *login_button; //登录按钮
static GtkWidget *target_entry;

GtkTextBuffer *file_buffer;
GtkWidget *path_entry;
char *file_path;

void sys_err(const char *ptr,int num)
{
    perror(ptr);
    exit(num);
}

void get_message()
{
	GtkTextIter iter;
	gchar get_buf[MAX_LEN];
	gchar buf[MAX_LEN];
	
	char mod;

	while(read(sd, buf, MAX_LEN) != -1) //只要读取数据成功就循环执行
	{
		printf("%s\n", buf);
		mod = buf[0];
		if (mod == '1')
		{
			g_print("%s", buf + 2);
			sprintf(get_buf, "%s", buf + 2);
			gdk_threads_enter(); //进入
			gtk_text_buffer_get_end_iter(buffer, &iter);
			gtk_text_buffer_insert(buffer, &iter, get_buf, -1);
			memset(buf, 0, sizeof(buf));
			gdk_threads_leave();
		}
		else if (mod == '2')
		{
			printf("download\n");
			download_file(buf);
		}
	}
}

gboolean do_connect() //连接多人聊天服务器
{
	GtkTextIter iter;
	gint slen;
	sd = socket(AF_INET,SOCK_STREAM,0);//创建
	if (sd < 0)
	{
		gtk_text_buffer_get_end_iter(buffer, &iter);
		gtk_text_buffer_insert(buffer, &iter, "打开套接字时出错！\n", -1);
		return FALSE;
	}
	
	memset(&s_in, 0, sizeof(s_in));
	s_in.sin_family = AF_INET;
	s_in.sin_port = htons(OURPORT);
	s_in.sin_addr.s_addr = inet_addr("192.168.153.136");
	slen = sizeof(struct sockaddr_in);
	
	if (connect(sd, (struct sockaddr*)&s_in, 