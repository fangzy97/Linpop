/* client.c */
#include "function.h"

#define OURPORT 8088
#define MAX_LEN 2048

gint sd; //套接字句柄
struct sockaddr_in s_in; //套接字数据结构
gchar username[64]; //用户名
//gchar target[64];
gchar buf[MAX_LEN]; //写缓冲区
gchar get_buf[MAX_LEN]; //读缓冲区
gboolean isconnected = FALSE; //定义逻辑值表示是否连接

static GtkWidget *text;
static GtkTextBuffer *buffer; //显示对话内容的文本显示缓冲区
static GtkWidget *message_entry; //显示输入消息的单行录入控件
static GtkWidget *name_entry; //输入用户名的单行录入控件
static GtkWidget *login_button; //登录按钮
static GtkWidget *target_entry;
static GtkWidget *path_entry;

char *file_path;

void sys_err(const char *ptr,int num)
{
    perror(ptr);
    exit(num);
}

void get_file()
{
	int fd = open(file_path, O_RDONLY);
	char buf[MAX_LEN + 10];
	if (fd < 0)
	{
		sys_err("open", -3);
	}

	int tmp = 0;
	while (1)
	{
		int len = read(fd, buf + tmp, sizeof(char) * MAX_LEN);
		
		if (len == 0) break;	//读取出错

		if (len > 0)
		{
			tmp += len;
		}

		char *temp = NULL;
		temp = (char*)malloc(sizeof(char) * MAX_LEN + 10);
		memset(temp, 0, sizeof(temp));
		
		strcpy(temp, "2:");
		strcat(temp, buf);
		len += 2;

		// 考虑一次没读完
		int _tmp = 0;
		while (1)
		{
			int ret = write(sd, temp + _tmp, len - _tmp);
			if (ret > 0)
			{
				_tmp += ret;
			}
			if (_tmp == ret)
			{
				break;
			}
			if (ret < 0)
			{
				perror("write");
				break;
			}
		}

		if (temp != NULL)
		{
			free(temp);
			temp = NULL;
		}
	}
}

void get_message()
{
	GtkTextIter iter;
	gchar get_buf[MAX_LEN];
	gchar buf[MAX_LEN];

	while(read(sd, buf, MAX_LEN) != -1) //只要读取数据成功就循环执行
	{
		g_print("%s", buf);
		sprintf(get_buf,"%s",buf);
		gdk_threads_enter(); //进入
		gtk_text_buffer_get_end_iter(buffer, &iter);
		gtk_text_buffer_insert(buffer, &iter, get_buf, -1);
		memset(buf, 0, sizeof(buf));
		gdk_threads_leave();
	}
}

gboolean do_connect() //连接多人聊天服务器
{
	GtkText